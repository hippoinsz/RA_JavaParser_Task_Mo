package TaskSolution;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.Node;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.stmt.BlockStmt;
import com.github.javaparser.ast.visitor.VoidVisitorAdapter;
import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JarTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;
import com.github.javaparser.symbolsolver.utils.SymbolSolverCollectionStrategy;
import com.github.javaparser.utils.ProjectRoot;
import com.github.javaparser.utils.SourceRoot;

public class Task3 {

	private static String getFullyQualifiedName(ClassOrInterfaceDeclaration c2) {
		String name = "";
		ClassOrInterfaceDeclaration parentClass = c2.getParentNode().isPresent() ? getClass(c2.getParentNode().get())
				: null;
		if (parentClass != null) {
			name += getFullyQualifiedName(parentClass) + ".";
		} else {
			CompilationUnit u = getCompilationUnit(c2);
			if (u != null && u.getPackageDeclaration().isPresent()) {
				name += u.getPackageDeclaration().get().getNameAsString() + ".";
			}
		}
		return name + c2.getNameAsString();
	}

	private static ClassOrInterfaceDeclaration getClass(Node n1) {
		while (!(n1 instanceof ClassOrInterfaceDeclaration)) {
			if (n1.getParentNode().isPresent()) {
				n1 = n1.getParentNode().get();
			} else
				return null;
		}
		return (ClassOrInterfaceDeclaration) n1;
	}

	private static CompilationUnit getCompilationUnit(Node n1) {
		while (!(n1 instanceof CompilationUnit)) {
			if (n1.getParentNode().isPresent()) {
				n1 = n1.getParentNode().get();
			} else
				return null;
		}
		return (CompilationUnit) n1;
	}

	private static String src_dir = "/Users/fubinmo/git/avro/lang/java/";
	private static String jar_dir = null;
	// "/Users/fubinmo/git/avro/lang/java/avro/src/test/java/org/apache/avro/TestDataFileMeta.java",
	// "/Users/fubinmo/git/avro/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolGeneric.java"
	// "/Users/fubinmo/git/avro/lang/java/avro/src/test/java/org/apache/avro/io/parsing/TestResolvingGrammarGenerator.java",
	private static String[] filePaths = {"/Users/fubinmo/git/avro/lang/java/avro/src/test/java/org/apache/avro/TestDataFileMeta.java",
			"/Users/fubinmo/git/avro/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolGeneric.java",
			"/Users/fubinmo/git/avro/lang/java/avro/src/test/java/org/apache/avro/io/parsing/TestResolvingGrammarGenerator.java"};

	private static class MethodCallExpressionVisitor extends VoidVisitorAdapter<Void> {

		public InformationEntity ie = new InformationEntity();

		@SuppressWarnings({ "deprecation" })
		@Override
		public void visit(ClassOrInterfaceDeclaration cd, Void arg) {

			List<MethodDeclaration> mdList = new ArrayList<MethodDeclaration>();
			List<String> qulifiedNames = new ArrayList<String>();
			Map<String, Set<MethodCallExpr>> assertExpresions = new HashMap<>();

			String classQualifiedName = getFullyQualifiedName(cd);

			for (MethodDeclaration md : cd.getMethods()) {
				String qulifeidName = classQualifiedName + "." + md.getNameAsString();
				Set<MethodCallExpr> assertExpresions4SingelMethod = new HashSet<MethodCallExpr>();
				for (Node annotation : md.getAnnotations()) {
					if (annotation.toString().contains("@Test")) {
						mdList.add(md);
						qulifiedNames.add(qulifeidName);
					}
				}

				BlockStmt bs = md.getBody().get();
				for (Node statement : bs.getStatements()) {
					for (MethodCallExpr mce : statement.getNodesByType(MethodCallExpr.class)) {
						if (mce.toString().contains("assert") || mce.toString().contains("Assert")) {
							assertExpresions4SingelMethod.add(mce);
						}
					}
				}

				assertExpresions.put(qulifeidName, assertExpresions4SingelMethod);
			}

			ie.setMethodDeclarations(mdList);
			ie.setClassQualifiedName(classQualifiedName);
			ie.setMethodQulifiedName(qulifiedNames);
			ie.setAssertExpresions(assertExpresions);

		}

	}

	private void initCombinedSolver() throws IOException {
		CombinedTypeSolver combinedSolver = new CombinedTypeSolver();
		TypeSolver reflectionTypeSolver = new ReflectionTypeSolver();

		File file = new File(src_dir);
		// get src root
		final ProjectRoot projectRoot = new SymbolSolverCollectionStrategy().collect(file.toPath());
		List<SourceRoot> sourceRootList = projectRoot.getSourceRoots();
		// add java jre solver
		combinedSolver.add(reflectionTypeSolver);
		// add src roots into combined solver
		for (SourceRoot sourceRoot : sourceRootList) {
			combinedSolver.add(new JavaParserTypeSolver(sourceRoot.getRoot()));
		}
		// add jar solver
		if (jar_dir != null) {
			for (File jar_File : new File(jar_dir).listFiles()) {
				combinedSolver.add(new JarTypeSolver(jar_File));
			}
		}
	}

	public static void main(String[] args) {

		Task3 task = new Task3();

		try {
			task.initCombinedSolver();

			for (String path : filePaths) {
				System.out.println("***************************");
				System.out.println("This is the " + path.substring(path.lastIndexOf("/") + 1) + " Class");
				CompilationUnit cu = StaticJavaParser.parse(new File(path));
				MethodCallExpressionVisitor rv = new MethodCallExpressionVisitor();
				cu.accept(rv, null);

				for (String mqn : rv.ie.methodQulifiedName) {
					System.out.println(mqn);
					System.out.println(rv.ie.getAssertExpresions().get(mqn));
				}

			}
		} catch (Exception e) {
			e.printStackTrace();
		}

	}

}
